<!--
 * @Author: wuhaoyuan
 * @Date: 2022-07-06 10:10:21
 * @LastEditTime: 2022-07-06 10:21:15
 * @LastEditors: wuhaoyuan
 * @Description:
 * @FilePath: /blog/web进阶知识/js 事件循环机制.md
-->

# js 事件循环机制

## 前言

一次面试的问题：说说什么是事件循环机制？宏任务、微任务是什么？为什么有了宏任务还要有微任务？

## 什么是事件循环机制

在了解事件循环前，需要一些有关 JS 特性的前置知识。

JS 引擎是单线程的，直白来说就是一个时间点下 JS 引擎只能去做一件事情，而 Java 这种多线程语言，可以同时做几件事情。

JS 做的任务分为同步和异步两种，所谓 "异步"，简单说就是一个任务不是连续完成的，先执行第一段，等做好了准备，再回过头执行第二段，第二段也被叫做回调；同步则是连贯完成的。

像读取文件、网络请求这种任务属于异步任务：花费时间很长，但中间的操作不需要 JS 引擎自己完成，它只用等别人准备好了，把数据给他，他再继续执行回调部分。

如果没有特殊处理，JS 引擎在执行异步任务时，应该是存在等待的，不去做任何其他事情。用一个图来展示这个过程，可以看出，在执行异步任务时有大量的空闲时间被浪费。

![](/img/1313648-20220317094802650-1090634371.png)

实际上这是大多数多线程语言的处理办法。但对于 JS 这种单线程语言来说，这种长时间的空闲等待是不可接受的：遇到其他紧急任务，Java 可以再开一个线程去处理，JS 却只能忙等。

所以采取了以下的“异步任务回调通知”模式：

![](/img/1313648-20220317094810806-801927766.png)

在等待异步任务准备的同时，JS 引擎去执行其他同步任务，等到异步任务准备好了，再去执行回调。这种模式的优势显而易见，完成相同的任务，花费的时间大大减少，这种方式也被叫做非阻塞式。

而实现这个“通知”的，正是事件循环，把异步任务的回调部分交给事件循环，等时机合适交还给 JS 线程执行。事件循环并不是 JavaScript 首创的，它是计算机的一种运行机制。

事件循环是由一个队列组成的，异步任务的回调遵循先进先出，在 JS 引擎空闲时会一轮一轮地被取出，所以被叫做循环。

根据队列中任务的不同，分为宏任务和微任务。

## 宏任务和微任务

事件循环由宏任务和在执行宏任务期间产生的所有微任务组成。完成当下的宏任务后，会立刻执行所有在此期间入队的微任务。

这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。

常见的宏任务有：script（整体代码）/`setTimout`/`setInterval`/`setImmediate`(node 独有)/`requestAnimationFrame`(浏览器独有)/IO/UI render（浏览器独有）

常见的微任务有：`process.nextTick`(node 独有)/`Promise.then()`/`Object.observe`/`MutationObserver`

### 宏任务 setTimeout 的误区

setTimeout 的回调不一定在指定时间后能执行。而是在指定时间后，将回调函数放入事件循环的队列中。

如果时间到了，JS 引擎还在执行同步任务，这个回调函数需要等待；如果当前事件循环的队列里还有其他回调，需要等其他回调执行完。

另外，setTimeout 0ms 也不是立刻执行，它有一个默认最小时间，为 4ms。所以下面这段代码的输出结果不一定：

```js
// node
setTimeout(() => {
  console.log("setTimeout");
}, 0);
setImmediate(() => {
  console.log("setImmediate");
});
```

因为取出第一个宏任务之前在执行全局 Script，如果这个时间大于 4ms，这时 `setTimeout` 的回调函数已经放入队列，就先执行 `setTimeout`；如果准备时间小于 4ms，就会先执行 `setImmediate`

## 浏览器的事件循环

浏览器的事件循环由一个宏任务队列+多个微任务队列组成。

首先，执行第一个宏任务：全局 Script 脚本。产生的的宏任务和微任务进入各自的队列中。执行完 Script 后，把当前的微任务队列清空。完成一次事件循环。

接着再取出一个宏任务，同样把在此期间产生的回调入队。再把当前的微任务队列清空。以此往复。

宏任务队列只有一个，而每一个宏任务都有一个自己的微任务队列，每轮循环都是由一个宏任务+多个微任务组成。

```js
Promise.resolve().then(() => {
  console.log("第一个回调函数：微任务1");
  setTimeout(() => {
    console.log("第三个回调函数：宏任务2");
  }, 0);
});
setTimeout(() => {
  console.log("第二个回调函数：宏任务1");
  Promise.resolve().then(() => {
    console.log("第四个回调函数：微任务2");
  });
}, 0);
// 第一个回调函数：微任务1
// 第二个回调函数：宏任务1
// 第四个回调函数：微任务2
// 第三个回调函数：宏任务2
```

打印的结果不是从 1 到 4，而是先执行第四个回调函数，再执行第三个，因为它是一个微任务，比第三个回调函数有更高优先级。

原文：[什么是事件循环](https://www.cnblogs.com/cangqinglang/p/16015977.html)

其他文章：

- [【前端 100 问】Q24：浏览器和-Node-事件循环的区别.md](https://github.com/alanwhy/blog/blob/2b81cf5d5424a581dc92516f0db9aa015f081d6c/%E5%89%8D%E7%AB%AF100%E9%97%AE/%E3%80%90%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%91Q24%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C-Node-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB.md)
- [JavaScript 运行机制.md](https://github.com/alanwhy/blog/blob/88c75f9e9481bb438ddcfb20233abfa83b7cbdd2/web%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.md)
- [【前端 100 问】Q10：异步笔试题：async-await-setTimeout-Promise.md](https://github.com/alanwhy/blog/blob/2b81cf5d5424a581dc92516f0db9aa015f081d6c/%E5%89%8D%E7%AB%AF100%E9%97%AE/%E3%80%90%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%91Q10%EF%BC%9A%E5%BC%82%E6%AD%A5%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%9Aasync-await-setTimeout-Promise.md)
